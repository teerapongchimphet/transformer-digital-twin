<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Transformer — Manual Coil Temperatures (Radial Center Hotspot)</title>

  <script type="importmap">
  {"imports":{
    "three":"https://unpkg.com/three@0.155.0/build/three.module.js",
    "three/addons/":"https://unpkg.com/three@0.155.0/examples/jsm/"
  }}
  </script>

  <style>
    :root{--hud-bg:rgba(0,0,0,.55)}
    html,body{margin:0;height:100%;background:#0f1115;color:#eee;font-family:system-ui,Segoe UI,Roboto,Arial}
    #hud{position:fixed;left:12px;top:12px;background:var(--hud-bg);padding:12px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.25);z-index:10;min-width:280px}
    #hud h1{margin:0 0 6px 0;font-size:16px}
    .row{display:flex;gap:8px;align-items:center;margin:6px 0}
    .row label{width:64px;opacity:.9}
    .row input[type=range]{flex:1}
    .chip{display:inline-block;min-width:54px;padding:2px 8px;border-radius:999px;background:#1f2430;border:1px solid #333;text-align:center;font-variant-numeric:tabular-nums}
    .btn{background:#1f2430;border:1px solid #333;color:#eee;padding:4px 8px;border-radius:8px;cursor:pointer;margin-right:6px}
    small.mute{opacity:.75}
    canvas{display:block}
  </style>
</head>
<body>
  <div id="hud">
    <h1>Transformer (Manual Coils)</h1>
    <div class="row">
      <button id="fitBtn" class="btn">Auto-fit</button>
      <button id="logBtn" class="btn">Log Meshes</button>
    </div>
    <div class="row">
      <label>Coil 1</label>
      <input id="c1" type="range" min="25" max="60" step="0.1" value="35">
      <span id="t1" class="chip">35.0°C</span>
    </div>
    <div class="row">
      <label>Coil 2</label>
      <input id="c2" type="range" min="25" max="60" step="0.1" value="45">
      <span id="t2" class="chip">45.0°C</span>
    </div>
    <div class="row">
      <label>Coil 3</label>
      <input id="c3" type="range" min="25" max="60" step="0.1" value="55">
      <span id="t3" class="chip">55.0°C</span>
    </div>
    <small class="mute">Tip: drag to orbit, wheel to zoom</small>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    let scene, camera, renderer, controls, modelRoot=null;
    const coilMeshes=[];          // Wicklung*
    const coilOverlays=[];        // overlay meshes
    const overlayUniforms=[];     // uniforms ต่อคอยล์

    const MIN_T=25, MAX_T=60;

    const tmpV3=new THREE.Vector3();
    const tmpBox=new THREE.Box3();
    const tmpSize=new THREE.Vector3();

    init(); loadModel(); animate();

    function init(){
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0f1115);

      camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
      camera.position.set(6,4,8);

      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setPixelRatio(devicePixelRatio);
      renderer.setSize(innerWidth, innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      document.body.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      scene.add(new THREE.HemisphereLight(0xffffff,0x222233,0.9));
      const dir = new THREE.DirectionalLight(0xffffff,1.0);
      dir.position.set(6,8,4); scene.add(dir);

      const grid = new THREE.GridHelper(20,20,0x444444,0x222222);
      grid.position.y=0; scene.add(grid);
      scene.add(new THREE.AxesHelper(1));

      window.addEventListener('resize', ()=>{
        camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });

      document.getElementById('fitBtn').onclick = ()=> modelRoot && autoFit(modelRoot,true);
      document.getElementById('logBtn').onclick = ()=> logAllMeshes();

      ['c1','c2','c3'].forEach(id=>document.getElementById(id).addEventListener('input',applyTemps));
    }

    function loadModel(){
      const loader = new GLTFLoader();
      loader.load('Transformer1.glb', (gltf)=>{
        modelRoot = gltf.scene;
        modelRoot.scale.set(0.01,0.01,0.01);
        scene.add(modelRoot);

        const keys=['wicklung'];
        modelRoot.traverse(o=>{
          if(!o.isMesh) return;
          const n=(o.name||'').toLowerCase();
          if(!keys.some(k=>n.includes(k))) return;

          coilMeshes.push(o);

          // ===== Overlay + Shader แบบ "วงกลม" =====
          const {material, uniforms} = makeRadialOverlayMaterial();
          const overlay = new THREE.Mesh(o.geometry, material);
          overlay.name = (o.name||'coil')+'_overlay';
          overlay.matrixAutoUpdate = false;   // จะ sync ด้วย matrixWorld ของต้นฉบับ
          overlay.renderOrder = 999;
          scene.add(overlay);

          coilOverlays.push(overlay);
          overlayUniforms.push(uniforms);
        });

        if(coilMeshes.length===0) console.warn('ไม่พบ mesh ที่เป็นคอยล์ (ชื่อ Wicklung*)');

        autoFit(modelRoot,true);
        applyTemps();
      }, undefined, err=>console.error('Load GLB error:', err));
    }

    // วัสดุ overlay: additive, hotspot วงกลมจากกึ่งกลางคอยล์
    function makeRadialOverlayMaterial(){
      const uniforms = {
        uCenter:  { value: new THREE.Vector3() }, // world-space center
        uRadius:  { value: 0.5 },                 // รัศมีของ hotspot
        uHeat:    { value: 0.0 },                 // 0..1 จากสไลเดอร์
        uOpacity: { value: 0.6 },                 // ความทึบพื้นฐาน
        uStrength:{ value: 0.9 }                  // ความแรงของ hotspot กลาง
      };

      const vertexShader = /* glsl */`
        varying vec3 vWorldPos;
        void main(){
          vec4 wp = modelMatrix * vec4(position,1.0);
          vWorldPos = wp.xyz;
          gl_Position = projectionMatrix * viewMatrix * wp;
        }
      `;

      const fragmentShader = /* glsl */`
        precision highp float;
        varying vec3 vWorldPos;
        uniform vec3  uCenter;
        uniform float uRadius;
        uniform float uHeat, uOpacity, uStrength;

        void main(){
          // ระยะเชิงรัศมีจากศูนย์กลางคอยล์บนระนาบ XZ
          vec2 d = vWorldPos.xz - uCenter.xz;
          float r = length(d);
          // falloff = 1 ที่แกนกลาง, 0 ที่ขอบรัศมี
          float falloff = clamp(1.0 - smoothstep(0.0, uRadius, r), 0.0, 1.0);

          // เขียว -> เหลือง
          vec3 cold = vec3(0.0,1.0,0.0);
          vec3 hot  = vec3(1.0,1.0,0.0);
          vec3 base = mix(cold, hot, clamp(uHeat,0.0,1.0));

          // ความเข้มรวม
          float alpha = uOpacity * (0.35 + 0.65*uHeat);
          vec3 color  = base * (alpha + uStrength * falloff * uHeat);

          gl_FragColor = vec4(color, alpha); // additive blending
        }
      `;

      const material = new THREE.ShaderMaterial({
        uniforms, vertexShader, fragmentShader,
        transparent: true,
        depthWrite: false,
        depthTest: true,
        blending: THREE.AdditiveBlending,
        polygonOffset: true,
        polygonOffsetFactor: -1,
        polygonOffsetUnits: -1
      });

      return { material, uniforms };
    }

    function autoFit(root, log=false){
      const box=new THREE.Box3().setFromObject(root);
      const center=box.getCenter(new THREE.Vector3());
      root.position.sub(center);

      const box2=new THREE.Box3().setFromObject(root);
      const size2=box2.getSize(new THREE.Vector3());
      root.position.y += size2.y/2;

      const maxDim=Math.max(size2.x,size2.y,size2.z);
      const fov=camera.fov*Math.PI/180;
      const camDist = Math.abs(maxDim/(2*Math.tan(fov/2)))*1.8;
      camera.position.set(camDist,camDist*0.6,camDist);
      camera.near=Math.max(0.001,camDist/100); camera.far=camDist*100; camera.updateProjectionMatrix();
      controls.target.set(0,size2.y*0.55,0); controls.update();
      if(log) console.log('[FIT] size:', size2, 'camDist:', camDist.toFixed(2));
    }

    function logAllMeshes(){
      if(!modelRoot) return;
      const names=[]; modelRoot.traverse(o=>{ if(o.isMesh) names.push(o.name||'(unnamed)'); });
      console.log('[MESH]', names);
    }

    function applyTemps(){
      const temps = [
        parseFloat(document.getElementById('c1').value),
        parseFloat(document.getElementById('c2').value),
        parseFloat(document.getElementById('c3').value)
      ];
      document.getElementById('t1').textContent = temps[0].toFixed(1)+'°C';
      document.getElementById('t2').textContent = temps[1].toFixed(1)+'°C';
      document.getElementById('t3').textContent = temps[2].toFixed(1)+'°C';

      for(let i=0;i<overlayUniforms.length && i<temps.length;i++){
        const k = THREE.MathUtils.clamp((temps[i]-MIN_T)/(MAX_T-MIN_T),0,1);
        overlayUniforms[i].uHeat.value = k;
      }
    }

    // sync overlay transforms + อัปเดต center/radius เป็น "กึ่งกลางคอยล์ + รัศมีวง"
    function syncOverlays(){
      for(let i=0;i<coilOverlays.length && i<coilMeshes.length;i++){
        const src = coilMeshes[i];
        const dst = coilOverlays[i];
        const uni = overlayUniforms[i];

        // ติดตามทรานส์ฟอร์ม
        src.updateWorldMatrix(true,false);
        dst.matrix.copy(src.matrixWorld);
        dst.matrixWorldNeedsUpdate = true;

        // ศูนย์กลาง + รัศมีจากขนาดหน้าตัด X/Z
        tmpBox.setFromObject(src);
        tmpBox.getCenter(tmpV3);
        tmpBox.getSize(tmpSize);

        uni.uCenter.value.copy(tmpV3);
        // ใช้รัศมีเป็น 45% ของหน้าตัดที่เล็กกว่า เพื่อให้ "วงกลม" อยู่ภายในคอยล์
        uni.uRadius.value = 0.45 * Math.min(tmpSize.x, tmpSize.z);
      }
    }

    function animate(){
      requestAnimationFrame(animate);
      controls.update();
      syncOverlays();
      renderer.render(scene,camera);
    }
  </script>
</body>
</html>
