<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Transformer — Manual Coil Temperatures (Elliptical Hotspot)</title>

  <!-- Import Map -->
  <script type="importmap">
  {"imports":{
    "three":"https://unpkg.com/three@0.155.0/build/three.module.js",
    "three/addons/":"https://unpkg.com/three@0.155.0/examples/jsm/"
  }}
  </script>

  <style>
    :root{--hud-bg:rgba(0,0,0,.55)}
    html,body{margin:0;height:100%;background:#0f1115;color:#eee;font-family:system-ui,Segoe UI,Roboto,Arial}
    #hud{position:fixed;left:12px;top:12px;background:var(--hud-bg);padding:12px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.25);z-index:10;min-width:290px}
    #hud h1{margin:0 0 6px 0;font-size:16px}
    .row{display:flex;gap:8px;align-items:center;margin:6px 0}
    .row label{width:64px;opacity:.9}
    .row input[type=range]{flex:1}
    .chip{display:inline-block;min-width:54px;padding:2px 8px;border-radius:999px;background:#1f2430;border:1px solid #333;text-align:center;font-variant-numeric:tabular-nums}
    .btn{background:#1f2430;border:1px solid #333;color:#eee;padding:4px 8px;border-radius:8px;cursor:pointer;margin-right:6px}
    small.mute{opacity:.75}
    canvas{display:block}
  </style>
</head>
<body>
  <div id="hud">
    <h1>Transformer (Manual Coils)</h1>
    <div class="row">
      <button id="fitBtn" class="btn">Auto-fit</button>
      <button id="logBtn" class="btn">Log Meshes</button>
    </div>
    <div class="row">
      <label>Coil 1</label>
      <input id="c1" type="range" min="25" max="60" step="0.1" value="35">
      <span id="t1" class="chip">35.0°C</span>
    </div>
    <div class="row">
      <label>Coil 2</label>
      <input id="c2" type="range" min="25" max="60" step="0.1" value="45">
      <span id="t2" class="chip">45.0°C</span>
    </div>
    <div class="row">
      <label>Coil 3</label>
      <input id="c3" type="range" min="25" max="60" step="0.1" value="55">
      <span id="t3" class="chip">55.0°C</span>
    </div>
    <small class="mute">Tip: drag = orbit, wheel = zoom</small>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // --- THREE setup ---
    let scene, camera, renderer, controls, modelRoot = null;
    const coilMeshes = []; // จะเก็บ 3 mesh: Wicklung*
    const coilShaders = []; // เก็บตัวชี้ uniforms ต่อคอยล์

    init();
    loadModel();
    animate();

    function init(){
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0f1115);

      camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
      camera.position.set(6,4,8);

      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setPixelRatio(devicePixelRatio);
      renderer.setSize(innerWidth, innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      document.body.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      scene.add(new THREE.HemisphereLight(0xffffff, 0x222233, 0.9));
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(6,8,4); scene.add(dir);

      const grid = new THREE.GridHelper(20,20,0x444444,0x222222);
      scene.add(grid);
      scene.add(new THREE.AxesHelper(1));

      window.addEventListener('resize', ()=>{
        camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });

      document.getElementById('fitBtn').onclick = ()=> modelRoot && autoFit(modelRoot,true);
      document.getElementById('logBtn').onclick = ()=> logAllMeshes();

      // bind sliders
      ['c1','c2','c3'].forEach((id)=> document.getElementById(id).addEventListener('input', applyTemps));
    }

    function loadModel(){
      const loader = new GLTFLoader();
      loader.load('Transformer1.glb', (gltf)=>{
        modelRoot = gltf.scene;
        modelRoot.scale.set(0.01,0.01,0.01);
        scene.add(modelRoot);

        // เลือกคอยล์ด้วยชื่อที่มีคำว่า "Wicklung"
        const keys = ['wicklung'];
        modelRoot.traverse(o=>{
          if (o.isMesh) {
            const n = (o.name||'').toLowerCase();
            if (keys.some(k=>n.includes(k))) {
              o.material = o.material.clone();
              // ปิด toneMappingExposure กระทบ emissive มากเกินไป
              if ('emissive' in o.material){ o.material.emissive.set(0x000000); o.material.emissiveIntensity = 0.0; }
              coilMeshes.push(o);
            }
          }
        });

        if (coilMeshes.length < 1) console.warn('ไม่พบ mesh ที่เป็นคอยล์ (ชื่อ Wicklung*)');

        // จัดตำแหน่งและกล้อง
        autoFit(modelRoot,true);

        // เตรียม shader ฮอตสปอตต่อคอยล์
        coilMeshes.forEach((mesh, idx)=> prepareHotspotShader(mesh, idx));

        // ลงสีตามค่าเริ่มต้นของสไลเดอร์
        applyTemps();
      }, undefined, (err)=> console.error('Load GLB error:', err));
    }

    // วางโมเดลบนกริดและจัดกล้อง
    function autoFit(root, log=false){
      const box = new THREE.Box3().setFromObject(root);
      const center = box.getCenter(new THREE.Vector3());
      root.position.sub(center);

      const box2 = new THREE.Box3().setFromObject(root);
      const size2 = box2.getSize(new THREE.Vector3());
      root.position.y += size2.y/2; // ฐานแตะ y=0

      const maxDim = Math.max(size2.x,size2.y,size2.z);
      const fov = camera.fov * Math.PI/180;
      const camDist = Math.abs(maxDim / (2*Math.tan(fov/2))) * 1.8;
      camera.position.set(camDist, camDist*0.6, camDist);
      camera.near = Math.max(0.001, camDist/100); camera.far = camDist*100;
      camera.updateProjectionMatrix();
      controls.target.set(0, size2.y*0.55, 0); controls.update();
      if (log) console.log('[FIT] size:', size2, 'camDist:', camDist.toFixed(2));
    }

    function logAllMeshes(){
      if (!modelRoot) return;
      const names = [];
      modelRoot.traverse(o=>{ if (o.isMesh) names.push(o.name||'(unnamed)'); });
      console.log('[MESH]', names);
    }

    // --- Hotspot shader per-coil ---
    function prepareHotspotShader(mesh, index){
      // หา center และรัศมีวงรีใน world จากขนาดกล่องล้อม (ใช้แนวราบ x,z)
      const box = new THREE.Box3().setFromObject(mesh);
      const centerWorld = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());
      const rx = Math.max(size.x*0.35, 0.001); // รัศมีแกน x ของวงรี
      const rz = Math.max(size.z*0.35, 0.001); // รัศมีแกน z ของวงรี

      // เก็บ uniforms ไว้ปรับภายหลัง
      const uniformsRef = {
        uCenter: { value: centerWorld.clone() },
        uRadii:  { value: new THREE.Vector2(rx, rz) },
        uCold:   { value: new THREE.Color(0x00ff00) }, // เขียว
        uHot:    { value: new THREE.Color(0xffff00) }, // เหลือง
        uT:      { value: 0.25 },                      // 0..1 จากอุณหภูมิ
        uEmi:    { value: 0.2 }                        // ความเรืองแสงพื้นฐาน
      };

      // patch shader
      mesh.material.onBeforeCompile = (shader)=>{
        // ผสาน uniforms
        Object.assign(shader.uniforms, uniformsRef);

        // ส่งผ่านตำแหน่งใน world
        shader.vertexShader = shader.vertexShader.replace(
          '#include <common>',
          `
          #include <common>
          varying vec3 vWorldPos;
          `
        ).replace(
          '#include <begin_vertex>',
          `
          #include <begin_vertex>
          vWorldPos = (modelMatrix * vec4(transformed, 1.0)).xyz;
          `
        );

        shader.fragmentShader = shader.fragmentShader.replace(
          '#include <common>',
          `
          #include <common>
          varying vec3 vWorldPos;
          uniform vec3 uCenter;
          uniform vec2 uRadii;
          uniform vec3 uCold;
          uniform vec3 uHot;
          uniform float uT;
          uniform float uEmi;
          `
        ).replace(
          'vec4 diffuseColor = vec4( diffuse, opacity );',
          `
          // base
          vec4 diffuseColor = vec4( diffuse, opacity );

          // ระยะเชิงวงรีในระนาบ xz (world)
          vec2 d = vec2( (vWorldPos.x - uCenter.x)/uRadii.x,
                         (vWorldPos.z - uCenter.z)/uRadii.y );
          float r = length(d);                 // r=0 กลางฮอตสปอต
          // โปรไฟล์กระจายตัวแบบ Gaussian
          float hotspot = exp(-4.0*r*r);       // แกนคมที่กลาง ค่อย ๆ จางออก
          // สัดส่วนสีรวม: อุณหภูมิพื้นฐาน + บูสต์จากฮอตสปอต
          float k = clamp(uT*0.85 + hotspot*0.9, 0.0, 1.0);
          vec3 heat = mix(uCold, uHot, k);

          diffuseColor.rgb = heat;
          `
        ).replace(
          '#include <emissivemap_fragment>',
          `
          #include <emissivemap_fragment>
          // เพิ่มความเรืองแสงตามฮอตสปอตเพื่อให้ดู "ร้อน"
          vec2 dE = vec2( (vWorldPos.x - uCenter.x)/uRadii.x,
                          (vWorldPos.z - uCenter.z)/uRadii.y );
          float rE = length(dE);
          float hotspotE = exp(-4.0*rE*rE);
          totalEmissiveRadiance += mix(uCold, uHot, clamp(uT,0.0,1.0)) * (uEmi + hotspotE*1.2);
          `
        );
        // เก็บอ้างอิงไว้ปรับแบบ real-time
        coilShaders[index] = { shader, uniforms: uniformsRef };
      };

      // บังคับคอมไพล์หนึ่งเฟรม
      mesh.material.needsUpdate = true;
    }

    // --- Manual temperatures ---
    const MIN_T = 25, MAX_T = 60;

    function applyTemps(){
      const t1 = parseFloat(document.getElementById('c1').value);
      const t2 = parseFloat(document.getElementById('c2').value);
      const t3 = parseFloat(document.getElementById('c3').value);
      document.getElementById('t1').textContent = t1.toFixed(1)+'°C';
      document.getElementById('t2').textContent = t2.toFixed(1)+'°C';
      document.getElementById('t3').textContent = t3.toFixed(1)+'°C';

      const temps = [t1,t2,t3];
      for (let i=0;i<coilMeshes.length && i<temps.length;i++){
        paintCoil(i, temps[i]);
      }
    }

    // แปลงอุณหภูมิเป็น 0..1 แล้วส่งเข้า uniforms (สีพื้นฐานยังคงเขียว→เหลือง)
    function paintCoil(idx, t){
      const k = THREE.MathUtils.clamp((t - MIN_T) / (MAX_T - MIN_T), 0, 1);
      const entry = coilShaders[idx];
      const mesh  = coilMeshes[idx];
      if (!mesh) return;

      try{
        // อัปเดตสี base (กันกรณี shader ยังไม่คอมไพล์)
        const GREEN  = new THREE.Color(0x00ff00);
        const YELLOW = new THREE.Color(0xffff00);
        const hex = GREEN.clone().lerp(YELLOW, k).getHex();
        mesh.material.color?.setHex?.(hex);
        if ('emissive' in mesh.material){
          mesh.material.emissive.setHex(hex);
          mesh.material.emissiveIntensity = 0.2 + 0.8*k;
        }

        // อัปเดต uniforms ของ shader ฮอตสปอต
        if (entry?.uniforms){
          entry.uniforms.uT.value = k;
          // สามารถปรับความเข้มเรืองแสงฐาน ถ้าต้องการ
          entry.uniforms.uEmi.value = 0.15 + 0.6*k;
        }
        mesh.material.needsUpdate = true;
      }catch(e){
        console.warn('update material failed on', mesh?.name, e);
      }
    }

    // --- render ---
    function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
