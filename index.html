<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Transformer Digital Twin — Coil Temp Loop + RT Chart</title>

  <!-- Import Map -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.155.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.155.0/examples/jsm/"
    }
  }
  </script>

  <style>
    html,body{margin:0;height:100%;background:#0f1115;color:#eee;font-family:system-ui,Segoe UI,Roboto,Arial}
    #hud{
      position:fixed;left:12px;top:12px;background:rgba(0,0,0,.55);
      padding:10px 12px;border-radius:10px;font-size:14px;line-height:1.45;
      box-shadow:0 6px 18px rgba(0,0,0,.25);z-index:10;backdrop-filter: blur(2px)
    }
    #hud b{font-size:16px}
    #btns{margin-top:6px;display:flex;gap:6px;flex-wrap:wrap}
    #btns button{background:#1f2430;border:1px solid #333;color:#eee;padding:4px 8px;border-radius:8px;cursor:pointer}
    #chartWrap{margin-top:8px}
    #chart{display:block;width:280px;height:100px;border-radius:8px;background:rgba(255,255,255,.03)}
    small.mute{opacity:.75}
    canvas{display:block}
  </style>
</head>
<body>
  <div id="hud">
    <div><b>Transformer (Loop 25→60→25)</b></div>
    <div>Temperature: <span id="temp">--</span> °C <small class="mute">(Coils)</small></div>
    <div id="btns">
      <button id="fitBtn">Auto-fit</button>
      <button id="logBtn">Log Meshes</button>
    </div>
    <div id="chartWrap">
      <canvas id="chart" width="280" height="100"></canvas>
      <div class="mute" style="display:flex;justify-content:space-between;">
        <span>real-time</span><span>25–60 °C</span>
      </div>
    </div>
    <div class="mute">Tip: drag to orbit, wheel to zoom</div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // ---------- THREE core ----------
    let scene, camera, renderer, controls;
    let coilMeshes = [];
    let modelRoot = null;

    // ---------- Temperature loop state ----------
    let temp = 25, targetTemp = 30;
    const MIN_T = 25, MAX_T = 60, STEP = 5;
    const HOLD_MS = 300, TWEEN_MS = 900;
    let tweenStart = performance.now();
    let fromTemp = temp;
    let direction = +1; // +1 up, -1 down
    const tempEl = document.getElementById('temp');

    // ---------- RT chart state ----------
    const chart = document.getElementById('chart');
    const ctx = chart.getContext('2d');
    let chartW = chart.clientWidth, chartH = chart.clientHeight;
    let dpr = Math.max(1, window.devicePixelRatio || 1);
    let series = [];
    const MAX_POINTS = 180;
    const SAMPLE_EVERY_MS = 160;
    let lastSample = 0;

    init();
    loadModel();
    animate();
    startRamp();
    initChartCanvas();
    window.addEventListener('resize', initChartCanvas);

    function init(){
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0f1115);

      camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
      camera.position.set(6, 4, 8);

      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setPixelRatio(devicePixelRatio);
      renderer.setSize(innerWidth, innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      document.body.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      scene.add(new THREE.HemisphereLight(0xffffff, 0x222233, 0.9));
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(6, 8, 4);
      scene.add(dir);

      const grid = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
      grid.position.y = 0;
      scene.add(grid);

      scene.add(new THREE.AxesHelper(1));

      document.getElementById('fitBtn').onclick = ()=> modelRoot && autoFit(modelRoot, true);
      document.getElementById('logBtn').onclick = ()=> logAllMeshes();

      window.addEventListener('resize', ()=>{
        camera.aspect = innerWidth/innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });
    }

    function loadModel(){
      const loader = new GLTFLoader();
      loader.load('Transformer1.glb', (gltf)=>{
        modelRoot = gltf.scene;
        modelRoot.scale.set(0.01, 0.01, 0.01);
        scene.add(modelRoot);

        // เลือกคอยล์: ชื่อมีคำว่า Wicklung
        const keys = ['wicklung'];
        modelRoot.traverse(obj=>{
          if (obj.isMesh) {
            const n = (obj.name||'').toLowerCase();
            if (keys.some(k=>n.includes(k))) {
              obj.material = obj.material.clone();
              if ('emissive' in obj.material) {
                obj.material.emissive.set(0x000000);
                obj.material.emissiveIntensity = 0.0;
              }
              coilMeshes.push(obj);
            }
          }
        });

        autoFit(modelRoot, true);
      }, undefined, (err)=> console.error('Load GLB error:', err));
    }

    // Put model on grid + fit camera
    function autoFit(root, log=false){
      const box = new THREE.Box3().setFromObject(root);
      const center = box.getCenter(new THREE.Vector3());
      root.position.sub(center);

      const box2 = new THREE.Box3().setFromObject(root);
      const size2 = box2.getSize(new THREE.Vector3());
      root.position.y += size2.y/2; // sit on grid (y=0)

      const maxDim = Math.max(size2.x, size2.y, size2.z);
      const fov = camera.fov * (Math.PI/180);
      const camDist = Math.abs(maxDim / (2 * Math.tan(fov/2))) * 1.8;
      camera.position.set(camDist, camDist*0.6, camDist);
      camera.near = Math.max(0.001, camDist/100);
      camera.far  = camDist*100;
      camera.updateProjectionMatrix();

      controls.target.set(0, size2.y*0.55, 0);
      controls.update();

      if (log) console.log('[FIT] size:', size2, 'camDist:', camDist.toFixed(2));
    }

    function logAllMeshes(){
      if (!modelRoot) return;
      const names = [];
      modelRoot.traverse(o=>{ if (o.isMesh) names.push(o.name||'(unnamed)'); });
      console.log('[MESH]', names);
    }

    // ---------- Temperature loop ----------
    function startRamp(){
      temp = MIN_T;
      fromTemp = MIN_T;
      targetTemp = MIN_T + STEP;
      direction = +1;
      tweenStart = performance.now();
      scheduleNextStep();
    }

    function scheduleNextStep(){
      setTimeout(()=>{
        fromTemp = temp;
        targetTemp = targetTemp + STEP * direction;

        if (targetTemp >= MAX_T) { targetTemp = MAX_T; direction = -1; }
        if (targetTemp <= MIN_T) { targetTemp = MIN_T; direction = +1; }

        tweenStart = performance.now();
        scheduleNextStep();
      }, TWEEN_MS + HOLD_MS);
    }

    function updateCoilsColor(t){
      const colorHex = tempToColor(t);
      const glow = emissiveByTemp(t);
      coilMeshes.forEach(m=>{
        try{
          m.material.color?.setHex?.(colorHex);
          if ('emissive' in m.material) {
            m.material.emissive.setHex(colorHex);
            if ('emissiveIntensity' in m.material) m.material.emissiveIntensity = glow;
          }
          m.material.needsUpdate = true;
        }catch(e){}
      });
    }

    function tempToColor(t){
      const ORANGE = new THREE.Color(0xff7a00);
      const RED    = new THREE.Color(0xff0000);
      const k = THREE.MathUtils.clamp((t - MIN_T) / (MAX_T - MIN_T), 0, 1);
      return ORANGE.clone().lerp(RED, k).getHex();
    }
    function emissiveByTemp(t){
      const k = THREE.MathUtils.clamp((t - MIN_T) / (MAX_T - MIN_T), 0, 1);
      return 0.2 + 0.8 * k;
    }

    // ---------- Real-time chart ----------
    function initChartCanvas(){
      chartW = chart.clientWidth; chartH = chart.clientHeight;
      dpr = Math.max(1, window.devicePixelRatio || 1);
      chart.width  = Math.floor(chartW * dpr);
      chart.height = Math.floor(chartH * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      drawChart(); // clear
    }

    function pushSample(val){
      series.push(val);
      while (series.length > MAX_POINTS) series.shift();
    }

    function drawChart(){
      ctx.clearRect(0,0,chartW,chartH);

      // grid
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 1;
      for (let i=1;i<=3;i++){
        const y = (chartH/4)*i;
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(chartW,y); ctx.stroke();
      }
      ctx.restore();

      if (series.length < 2) return;

      const yOf = (v)=> {
        const k = (v - MIN_T) / (MAX_T - MIN_T);
        return chartH - k * chartH;
      };

      ctx.beginPath();
      const stepX = chartW / (MAX_POINTS-1);
      for (let i=0;i<series.length;i++){
        const x = i*stepX;
        const y = yOf(series[i]);
        (i===0)?ctx.moveTo(x,y):ctx.lineTo(x,y);
      }
      const grd = ctx.createLinearGradient(0,0,chartW,0);
      grd.addColorStop(0,'#ffa657'); grd.addColorStop(1,'#ff4d4d');
      ctx.strokeStyle = grd; ctx.lineWidth = 2; ctx.stroke();

      ctx.lineTo(chartW, chartH); ctx.lineTo(0, chartH); ctx.closePath();
      ctx.fillStyle = 'rgba(255,120,0,0.08)'; ctx.fill();

      // last point
      const lx = (series.length-1)*stepX;
      const ly = yOf(series[series.length-1]);
      ctx.beginPath(); ctx.arc(lx, ly, 2.8, 0, Math.PI*2); ctx.fillStyle = '#fff'; ctx.fill();
    }

    // ---------- Render loop ----------
    function animate(now=performance.now()){
      requestAnimationFrame(animate);
      controls.update();

      const dt = (now - tweenStart) / TWEEN_MS;
      const u = THREE.MathUtils.clamp(dt, 0, 1);
      const eased = u<0.5 ? 4*u*u*u : 1 - Math.pow(-2*u+2, 3)/2;
      temp = THREE.MathUtils.lerp(fromTemp, targetTemp, eased);
      tempEl.textContent = temp.toFixed(1);
      updateCoilsColor(temp);

      if (now - lastSample > SAMPLE_EVERY_MS){
        pushSample(temp);
        lastSample = now;
        drawChart();
      }

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
