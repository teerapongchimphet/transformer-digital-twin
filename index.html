<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Transformer — Manual Coils (Radial Heat • Texture Overlay)</title>

  <script type="importmap">
  {"imports":{
    "three":"https://unpkg.com/three@0.155.0/build/three.module.js",
    "three/addons/":"https://unpkg.com/three@0.155.0/examples/jsm/"
  }}
  </script>

  <style>
    :root{--hud-bg:rgba(0,0,0,.55)}
    html,body{margin:0;height:100%;background:#0f1115;color:#eee;font-family:system-ui,Segoe UI,Roboto,Arial}
    #hud{position:fixed;left:12px;top:12px;background:var(--hud-bg);padding:12px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.25);z-index:10;min-width:320px}
    #hud h1{margin:0 0 6px 0;font-size:16px}
    .row{display:flex;gap:8px;align-items:center;margin:6px 0;flex-wrap:wrap}
    .row label{width:64px;opacity:.9}
    .row input[type=range]{flex:1}
    .chip{display:inline-block;min-width:54px;padding:2px 8px;border-radius:999px;background:#1f2430;border:1px solid #333;text-align:center;font-variant-numeric:tabular-nums}
    .btn{background:#1f2430;border:1px solid #333;color:#eee;padding:4px 8px;border-radius:8px;cursor:pointer;margin-right:6px}
    small.mute{opacity:.75}
    canvas{display:block}
    .switch{display:flex;align-items:center;gap:8px}
  </style>
</head>
<body>
  <div id="hud">
    <h1>Transformer (Radial Heat • Manual)</h1>
    <div class="row">
      <button id="fitBtn" class="btn">Auto-fit</button>
      <button id="logBtn" class="btn">Log Meshes</button>
      <label class="switch"><input id="heatOn" type="checkbox" checked> Heat ON</label>
    </div>
    <div class="row">
      <label>Coil 1</label>
      <input id="c1" type="range" min="25" max="60" step="0.1" value="35">
      <span id="t1" class="chip">35.0°C</span>
    </div>
    <div class="row">
      <label>Coil 2</label>
      <input id="c2" type="range" min="25" max="60" step="0.1" value="45">
      <span id="t2" class="chip">45.0°C</span>
    </div>
    <div class="row">
      <label>Coil 3</label>
      <input id="c3" type="range" min="25" max="60" step="0.1" value="60">
      <span id="t3" class="chip">60.0°C</span>
    </div>
    <small class="mute">Tip: drag to orbit, wheel to zoom</small>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    let scene, camera, renderer, controls, modelRoot=null;
    const coilMeshes=[], coilUniforms=[];
    const MIN_T=25, MAX_T=60;
    const tmpV3 = new THREE.Vector3();
    const tmpBox = new THREE.Box3();

    init(); loadModel(); animate();

    function init(){
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0f1115);

      camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
      camera.position.set(6,4,8);

      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setPixelRatio(devicePixelRatio);
      renderer.setSize(innerWidth, innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.debug.checkShaderErrors = true;
      document.body.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      scene.add(new THREE.HemisphereLight(0xffffff, 0x222233, 0.9));
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(6,8,4); scene.add(dir);

      const grid = new THREE.GridHelper(20,20,0x444444,0x222222);
      grid.position.y=0; scene.add(grid);
      scene.add(new THREE.AxesHelper(1));

      window.addEventListener('resize', ()=>{
        camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });

      document.getElementById('fitBtn').onclick = ()=> modelRoot && autoFit(modelRoot,true);
      document.getElementById('logBtn').onclick = ()=> logAllMeshes();
      ['c1','c2','c3','heatOn'].forEach(id=>document.getElementById(id).addEventListener('input',applyTemps));
    }

    function loadModel(){
      const loader = new GLTFLoader();
      loader.load('Transformer1.glb', (gltf)=>{
        modelRoot = gltf.scene;
        modelRoot.scale.set(0.01,0.01,0.01);
        scene.add(modelRoot);

        const keys=['wicklung','coil'];
        modelRoot.traverse(o=>{
          if(o.isMesh){
            const n=(o.name||'').toLowerCase();
            if(keys.some(k=>n.includes(k))){
              console.log('COIL FOUND:', o.name, `(${o.material?.type})`);
              const mat = makeRadialStandardMaterial(o.material);
              o.material = mat.material;
              o.material.needsUpdate = true;
              coilMeshes.push(o);
              coilUniforms.push(mat.uniforms);
            }
          }
        });

        if(coilMeshes.length===0) console.warn('ไม่พบคอยล์ (ใช้ Log Meshes ดูชื่อ mesh)');
        autoFit(modelRoot,true);
        applyTemps();
      }, undefined, err=>console.error('Load GLB error:', err));
    }

    // สร้าง ShaderMaterial ที่คงแสง/เงา + ซ้อน heat ทับ texture เดิม
    function makeRadialStandardMaterial(baseMat){
      const usePhysical = baseMat && /Physical/i.test(baseMat.type||'');
      const core = THREE.ShaderLib[ usePhysical ? 'physical' : 'standard' ];
      const uniforms = THREE.UniformsUtils.clone(core.uniforms);

      if ('roughness' in baseMat) uniforms.roughness.value = baseMat.roughness;
      if ('metalness' in baseMat) uniforms.metalness.value = baseMat.metalness;
      if (baseMat.color) uniforms.diffuse.value = baseMat.color.clone();
      if (baseMat.envMap) uniforms.envMap.value = baseMat.envMap;
      if (baseMat.emissive) uniforms.emissive.value = baseMat.emissive;

      const defines = usePhysical ? { PHYSICAL: '' } : { STANDARD: '' };
      if (baseMat.map) { uniforms.map.value = baseMat.map; defines.USE_MAP = ''; }

      uniforms.uCenter = { value: new THREE.Vector3() };
      uniforms.uRadius = { value: 0.5 };
      uniforms.uHeat   = { value: 0.0 };
      uniforms.uMix    = { value: 1.0 }; // 0=ปิด heat, 1=เปิด

      const vertexShader =
        'varying vec3 vWorldPos;\n' +
        core.vertexShader.replace(
          '#include <project_vertex>',
          `
          vec4 wp = modelMatrix * vec4( transformed, 1.0 );
          vWorldPos = wp.xyz;
          #include <project_vertex>
          `
        );

      const fragmentShader =
        'varying vec3 vWorldPos;\n' +
        'uniform vec3 uCenter; uniform float uRadius; uniform float uHeat; uniform float uMix;\n' +
        core.fragmentShader.replace(
          '#include <output_fragment>',
          `
          {
            float r = length( vWorldPos.xz - uCenter.xz );
            float falloff = 1.0 - smoothstep(0.0, uRadius, r);

            // เขียว -> เหลือง -> ส้ม/แดง
            float k = clamp(uHeat, 0.0, 1.0);
            vec3 g = vec3(0.0,1.0,0.0);
            vec3 y = vec3(1.0,1.0,0.0);
            vec3 rCol = vec3(1.0,0.3,0.0);
            vec3 heatColor = mix( mix(g,y, smoothstep(0.0,0.6,k)), rCol, smoothstep(0.6,1.0,k) );

            vec3 shaded = outgoingLight;                // ผลแสงเงาเดิม
            float globalMix = (uMix > 0.5) ? (0.55 + 0.45 * k) : 0.0;
            vec3 tintMul = mix(vec3(1.0), heatColor, globalMix);
            vec3 lit = shaded * tintMul;

            float centerBoost = (uMix > 0.5) ? (0.75 * falloff * k) : 0.0;
            lit += heatColor * centerBoost;

            gl_FragColor = vec4(lit, diffuseColor.a);
            #include <tonemapping_fragment>
            #include <colorspace_fragment>
          }
          `
        );

      const material = new THREE.ShaderMaterial({
        uniforms, vertexShader, fragmentShader,
        lights: true, fog: true, defines
      });

      material.transparent = baseMat.transparent;
      material.opacity     = baseMat.opacity;
      material.side        = baseMat.side;
      material.skinning    = baseMat.skinning || false;
      material.morphTargets= baseMat.morphTargets || false;
      material.morphNormals= baseMat.morphNormals || false;
      material.toneMapped  = true;

      return { material, uniforms };
    }

    function autoFit(root, log=false){
      const box = new THREE.Box3().setFromObject(root);
      const center = box.getCenter(new THREE.Vector3());
      root.position.sub(center);

      const box2 = new THREE.Box3().setFromObject(root);
      const size2 = box2.getSize(new THREE.Vector3());
      root.position.y += size2.y/2;

      const maxDim = Math.max(size2.x, size2.y, size2.z);
      const fov = camera.fov * Math.PI/180;
      const camDist = Math.abs(maxDim/(2*Math.tan(fov/2))) * 1.8;
      camera.position.set(camDist, camDist*0.6, camDist);
      camera.near = Math.max(0.001, camDist/100);
      camera.far  = camDist*100;
      camera.updateProjectionMatrix();
      controls.target.set(0, size2.y*0.55, 0);
      controls.update();
      if (log) console.log('[FIT] size:', size2, 'camDist:', camDist.toFixed(2));
    }

    function logAllMeshes(){
      if(!modelRoot) return;
      const names=[]; modelRoot.traverse(o=>{ if(o.isMesh) names.push(`${o.name||'(unnamed)'} • ${o.material?.type||'-'}`); });
      console.log('[MESH]', names);
    }

    function applyTemps(){
      const temps=[
        parseFloat(document.getElementById('c1').value),
        parseFloat(document.getElementById('c2').value),
        parseFloat(document.getElementById('c3').value)
      ];
      const heatOn = document.getElementById('heatOn').checked ? 1.0 : 0.0;

      document.getElementById('t1').textContent = temps[0].toFixed(1)+'°C';
      document.getElementById('t2').textContent = temps[1].toFixed(1)+'°C';
      document.getElementById('t3').textContent = temps[2].toFixed(1)+'°C';

      for(let i=0;i<coilUniforms.length && i<temps.length;i++){
        const k = THREE.MathUtils.clamp((temps[i]-MIN_T)/(MAX_T-MIN_T),0,1);
        coilUniforms[i].uHeat.value = k;
        coilUniforms[i].uMix.value  = heatOn;
        console.log(`[HEAT] coil${i+1}: T=${temps[i].toFixed(1)}°C  k=${k.toFixed(3)}  on=${heatOn}`);
      }
    }

    function animate(){
      requestAnimationFrame(animate);
      controls.update();

      // อัปเดต center/radius จาก bounding box ของแต่ละคอยล์
      for(let i=0;i<coilMeshes.length && i<coilUniforms.length;i++){
        const mesh = coilMeshes[i];
        const uni  = coilUniforms[i];
        tmpBox.setFromObject(mesh);
        tmpBox.getCenter(tmpV3);
        uni.uCenter.value.copy(tmpV3);

        const size = tmpBox.getSize(new THREE.Vector3());
        uni.uRadius.value = 0.45 * Math.max(size.x, size.z);
      }

      renderer.render(scene,camera);
    }
  </script>
</body>
</html>
